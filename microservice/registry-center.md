### 角色

- RPC Server
- RPC Client
- Registry

### 功能

- RPC Server 提供服务，在启动时，根据服务发布文件 server.xml 中的配置的信息，向 Registry 注册自身服务，并向 Registry 定期发送心跳汇报存活状态。

- RPC Client 调用服务，在启动时，根据服务引用文件 client.xml 中配置的信息，向 Registry 订阅服务，把 Registry 返回的服务节点列表缓存在本地内存中，并与 RPC Sever 建立连接。
- 当 RPC Server 节点发生变更时，Registry 会同步变更，RPC Client 感知后会刷新本地内存中缓存的服务节点列表。
- RPC Client 从本地缓存的服务节点列表中，基于负载均衡算法选择一台 RPC Sever 发起调用。



### 实现功能

- 注册中心 API

  - 服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。
  - 服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。
  - 服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。
  - 服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。
  - 服务查询接口：查询注册中心当前注册了哪些服务信息。
  - 服务修改接口：修改注册中心中某一服务的信息。

- 集群部署

  采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。

  ZooKeeper 的工作原理：

  - 每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。
  - ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。
  - Leader 负责处理数据更新等操作（ZAB 协议）。一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。

- 目录存储

  以 ZooKeeper 为例，注册中心存储服务信息一般采用**层次化的目录结构**：
  
  - 每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。
  - znode 可以包含数据和子 znode。
  - znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。

- 服务健康状态检测

  以 ZooKeeper 为例，它是基于 ZooKeeper **客户端和服务端的长连接和会话超时控制机制**，来实现服务健康状态检测的。
  
  在 ZooKeeper 中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的 Session ID。服务端和客户端维持的是一个长连接，在 SESSION_TIMEOUT 周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping 消息），服务器重置下次 SESSION_TIMEOUT 时间。如果超过 SESSION_TIMEOUT 后服务端都没有收到客户端的心跳消息，则服务端认为这个 Session 就已经结束了，ZooKeeper 就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。
  
- 白名单机制

  注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。
