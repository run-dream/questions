### 微服务概览

### 起源

1. 单体架构

   优势: 易于开发，部署

   劣势: 随着规模变大，可维护性越来越差

2. SOA

3. 微服务 可以理解成SOA的最佳实践

   理论:

   - 小即是美 代码少 bug也少 易于维护
   - 单一职责
   - 尽可能早地创建原型
   - 可移植性比效率更加重要

#### 定义

围绕**业务功能**构建的，服务关注单一业务，服务间采用轻量的消息进行通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。

优点:

1. 原子服务
2. 独立进程
3. 隔离部署
4. 去中心化服务治理 减少集中化的负载均衡

缺点:

基础设施的建设、复杂度高。

- 分布式系统 引入RPC或者消息传递，来实现进程间通信
- 分区的数据架构
  - 分布式缓存
  - 分布式事务
- 测试复杂度
- 服务模块间的依赖
- 对运维基建的挑战比较大

### 实现

#### 组件服务化

- kit 微服务的基础库（框架）
- service 业务代码 + kit 依赖 + 第三方依赖组成的业务微服务
- RPC + message queue 轻量级通信

#### 按业务组织服务

you build it, you run it。

服务背后的小团队是跨功能的，包含业务所需的全面的技能。

模式：

- 大前端
- 网关接入
- 业务服务
- 平台服务
- 基础设施

#### 去中心化

- 数据去中心化
- 治理去中心和
- 技术去中心化

每个服务独享各自的数据存储服务，不共享数据库和缓存。

#### 基础设施的自动化

- CICD 

  gitlab + gitlab hooks + kubernetes

- Testing

  - 测试环境
  - 单元测试
  - API 自动化测试 YAPI

- 在线运行时

  - kuberbetes
  - Promitheus
  - ELK
  - Control Panel

#### 可用性 & 兼容性设计

- design for failure

### 微服务设计

- API Gateway

  解决的问题:

  1. 客户端到微服务的直接通信，强耦合
  2. 多次请求，客户端整合数据，工作量巨大，延迟高
  3. 协议不利于统一，各个部门间有差异，需要端来兼容
  4. 面对端的API适配耦合到了内部服务
  5. 多终端兼容逻辑复杂，每个服务都要处理
  6. 统一逻辑无法收敛，比如安全认证，限流

  定义：微服务统一的对外出口。

  优势:

  1. 轻量交互： 协议精简、聚合
  2. 差异服务:  数据裁剪以及聚合，针对终端定制接口
  3. 动态升级:  原有系统兼容升级，更新服务而非协议
  4. 沟通效率提升，协作模式演进为移动业务 + 网段小组

  类似于facade设计模式，适配服务

  缺点:

  API Gateway 存在 架构上单点故障 Envony

  将 API Gateway + BFF 分离 APIGateway 实现 跨横切面的功能 负责 路由 认证 限流 安全

- 微服务划分

  - 业务
    - 业务职能
    - DDD的限界上下文
  - CQRS 命令端和查询端

- 微服务安全

  - 使用Header的实行来注入用户信息
  - 认证和鉴权 
    - token
    - 证书

###  gRPC & 服务发现

- gRPC 优势

1. 多语言
2. 轻量级、高性能 序列化支持PB和JSON
3. 可插拔
4. IDL 基于文件定义服务 通过proto3工作生成指定语言的数据结构、服务端接口以及客户端stub
5. 设计理念
6. 移动端 基于标准http2设计。支持双向流、消息头压缩、单TCP的多路复用，服务端推送等特性
7. 服务而非对象，消息而非引用：促进微服务的系统间粗粒度消息交互设计理念
8. 负载无关的：不同的服务端需要使用不同的消息类型和编码 protocol buffer， JSON， XML，THRIFT
9. 流: Streaming API
10. 阻塞式和非阻塞式: 支持异步和同步处理在客户端和服务端间交互的消息序列
11. 元数据交互 常见的很切关注点 如 认证或跟踪，依赖数据交换
12. 标准化状态码：客户端通常以有限的方式响应API调用返回的错误

- Health Check

  平滑发布 缓存预热

  平滑下线

- 服务发现

  - 客户端发现 

    直连，比服务端服务发现少一次网络跳转， Consumer需要内置特定的服务发现客户端和发现逻辑。 

  - 服务端发现

    Consumer 无需关注服务发现集体细节，只需要知道服务的DNS域名即可，支持异构语言开发，需要基础设施支撑，多了一次网络跳转，可能有性能损失。

  - Service Mesh

  - AP 系统

    - ZooKeeper
      - 一致性影响可用性
      - 网络分区或抖动导致master节点时区联系而重新选举或超过半数不可用导致服务发现瘫痪
      - 大量服务长连接导致性能评价
    - Eureka

  - 通过 Family 和 Addr 定位实例，初次之外还可以附加更多的元数据：权重，染色标签，集群

    appid: 使用三段式命名， business.services.xxx

  - Provider 注册后定期心跳一次，注册，心跳，下线都需要进行同步，注册和下线需要进行长轮询推送

  - Consomer 启动时拉取实例，发起30s 长轮询

  - Server 定期检测失效的实例，失效则提出。短时间里丢失了大量的心跳链接，开启自我保护，保留过期服务不删除。

### 多集群 & 多租户

- 多集群必要性

  - 多节点保证可用性 至少 N + 2
  - 单一集群故障带来的影响面角度考虑冗余多套集群

- Paas 平台

  - 多套冗余的集群对应多套的缓存，带来更好的性能和冗余能力
  - 尽量避免业务隔离使用或者sharding 带来的 cache hit 影响

  业务隔离集群带来的问题是cache hit ratio 下降，不同业务形态数据正交

  subset 算法

- 多租户

  在一个微服务架构中，允许多系统共存是利用微服务稳定性以及模块化最有效的方式之一，这种方式被称为多租户。可以用来做并行测试。本质是跨服务传递请求携带上下文，数据隔离的流量路由方案。

  染色发布。

  - 流量路由 基于流入栈中的流量类型做路由
  - 隔离性 能够可靠的隔离测试和生产中的资源

  灰度发布会影响 1 / N 的节点数量。
