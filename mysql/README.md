### 基础架构

- 客户端
- 服务端
  - 连接器  （权限是和连接绑定的） show processlist
    - 连接管理
    - 登陆
    - 权限验证
  - 查询缓存 考虑到失效 不建议使用 mysql8.0后被删除
  - 分析器 
    - 词法解析
    - 语法解析
  - 优化器 [optimizer_trace](https://segmentfault.com/a/1190000018136007)
    - 选择索引
    - 指定表的内连接顺序 （建议小表驱动大表）
    - 生成执行计划 (explain)
  - 执行器
    - 调用引擎的接口，返回结果
  - 存储引擎
    - 存储数据，提供读写接口

### 日志系统

|          | 所在层级 | 作用                                      | 其他                                  |
| -------- | -------- | ----------------------------------------- | ------------------------------------- |
| binlog   | Server层 | 记录语句的原始逻辑                        | 逻辑日志 格式 statement，row 可追加写 |
| redolog  | 引擎层   | 记录在某个数据页上做了什么修改 crash-safe | 物理日志 ring-buffer 循环写           |
| undolog  | 引擎层 | 回滚事务                                  |                                       |
| relaylog | Server层 | 主从备份                                  |                                       |

- WAL技术 Write-Ahead Logging

  先写日志，再写磁盘，可以削减磁盘读写的压力, 将随机写转换成顺序写

- 两阶段提交 

  - 执行器找从内存->引擎找到数据

  - 执行器将新的数据调用引擎接口写数据

  - 引擎将数据更新到内存，再将更新操作写入 redolog 日志，此时redolog处于prepare状态
  - 执行器生成 binlog，并将binlog写如磁盘
  - 执行器调用引起的提交事务接口，引擎把redolog该车提交commit状态



### 事务隔离

- 事务特性

  - A 原子性  要么全部完成，要么全部不完成
  - C 一致性  事务开始之前和事务结束以后，数据库的完整性没有被破坏
  - I  隔离性  允许多个并发事务同时对其数据进行读写和修改的能力
  - D 持久性 事务处理结束后，对数据的修改就是永久的

- 多事务同时执行问题

  - 脏读   （读到其他事务未提交的数据）
  - 不可重复读 （读到其他事务update/delete后已提交的数据）
  - 幻读  （读到其他事务insert已经提交的数据）

- 事务隔离级别 transaction-isolation

  - 读未提交 （其他事务还没提交时，我的事务就能看到）
  - 读提交 （其他事务提交以后，我的事务才能看到）oracle,sqlserver,postgresql 默认隔离级别
  - 可重复读 （其他事务提交以后，我的事务也不去读） mysql 默认隔离级别
  - 串行 （其他事物尚未提交，我的事务就别想改数据） 锁

- 实现

  - [MVCC](https://draveness.me/database-concurrency-control/)

    每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回。

    具体来说是mysql通过在redolog里记录下更新的时间戳trx_id来实现了悲观锁。

    每一个版本的数据行都具有一个唯一的时间戳trx_id，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果(当前读)，然后创建一个新版本的数据，新数据的时间戳是目前数据行trx_id的最大版本 `＋1`。数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。

  - [悲观锁](https://segmentfault.com/a/1190000016611415)

- 长事务缺点

  - 系统中会存在很老的事务视图，为了保证可以回滚，会产生大量的回滚段
  - 占用锁资源



### 索引

- 常用的索引模型

  - 哈希表  只适用于等值查询

  - 有序数组 查询效率高 但是插入效率低 只适合于静态存储引擎

  - 搜索树 N叉树 N取决于数据块的大小 

    B 树 非叶子节点也能存储数据，而B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O

  - 跳表 实现简单

  - LSM 树

- InnoDB索引模型

  InnoDB的每个索引对应一颗B+树，表本身就是以主键为索引的B+树。

  节点的大小是页的大小。

  主键索引叶子节点存的是证行数据，非主键索引的叶子节点内容是主键的值。

  因此通过非主键索引的查询需要多搜索一次表，这被称为回表。

- [为什么InnoDB选择B+树作为索引](https://draveness.me/whys-the-design-mysql-b-plus-tree/)

  - InnoDB 需要支持的场景和功能需要在特定查询上拥有较强的性能
  - CPU 将磁盘上的数据加载到内存中需要花费大量的时间，这使得 B+ 树成为了非常好的选择

- 覆盖索引 包含查询要返回的所有数据，减少回表

- 最左前缀原则 联合索引

- 索引下推 在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表

- 加锁的范围

  - 全局锁 FTWRL 不支持事务的存储引擎全库逻辑备份

  - 表级锁

    - 表锁 lock tables t1 read, t2 write; unlock tables;

    - 元数据锁 MDL 表结构变更

      如何安全的给小表加字段：

      1. kill 掉长事务
      2. alter 语句里设定等待时间

      如何安全的给大表加字段

      1. alter table 容易导致服务崩溃
      2. 临时表
      3. pt-online-schema-change 工具

  - 行锁

    - 两阶段锁

      InnoDB事务中，行锁是在需要的时候才加上，但是不是用完就是释放，而是等到事务结束commit才释放。因此我们要把最容易出现死锁的地方放到事务的最后执行。

    - 死锁检测

      策略:

      - 等待超时 时间不好控制 
      - 死锁检测  耗费大量CPU资源 导致性能问题
        - 解决方案：
          1. 关掉死锁检测
          2. 控制并发度
          3. 在业务上将一行的逻辑改到逻辑上的多行逻辑
    
  - 事务的隔离性是如何保证的
  
    - MVCC
    - 1 row -> n trx_id 高低水位
    - 一致性视图
    - 更新时采用***当前读***  更新数据都是先读后写的，而这个读，只能读当前的值


### 参考资料
[高性能 MySQL](https://github.com/caijc00/programmer_bookshelf_cn/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%20%E7%AC%AC3%E7%89%88%20%E4%B8%AD%E6%96%87%20.pdf)

[InnoDB 锁](https://segmentfault.com/a/1190000014071758)