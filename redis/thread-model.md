### Redis 是不是单线程的？

回答：

是也不是。

对于核心网络模型，Redis一直都是单线程的。

但是对于整个Redis，并不是。

Redis  v4.0 为了解决删除超大的键值对引起的阻塞问题，引入多线程处理异步任务，提供了UNLINK，FLUSHALL ASYNC，FLUSHDB ASYNC 的异步命令。

Redis v6.0 正式在网络模型中实现 I/O 多线程， 不过只负责网络 I/O 和命令解析部分，命令执行部分仍然是由主线程处理的，目的是解决Redis  的网络 I/O 瓶颈。顺便一提，Redis 的多线程模式默认是关闭的。

### Redis 核心网络模型为何选择单线程？

关键词: ***实际场景*** ***好处***

回答：

- 从实际场景来考虑

  对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。

- 从单线程的优势来考虑：

  1. 避免了过多的上下文切换

     多线程调度过程中必然需要在 CPU 之间切换线程上下文 context，而上下文的切换又涉及程序计数器、堆栈指针和程序状态字等一系列的寄存器置换、程序堆栈重置甚至是 CPU 高速缓存、TLB 快表的汰换。

  2. 避免同步机制的开销

     只有一个线程就不用考虑锁的问题

  3. 简单可维护

     引入多线程必然会导致代码的复杂度上升和可维护性下降，同时加入锁以后会使得数据结构也要考虑线程安全的问题。

### 为什么单线程还这么快？

- **C 语言实现**，虽然 C 对 Redis 的性能有助力，但语言并不是最核心因素。

- **纯内存 I/O**，相较于其他基于磁盘的 DB，Redis 的纯内存操作有着天然的性能优势。
- **I/O 多路复用**，基于 epoll/select/kqueue 等 I/O 多路复用技术，实现高吞吐的网络 I/O。
- **单线程模型**，单线程无法利用多核，但是从另一个层面来说则避免了多线程频繁上下文切换，以及同步机制如锁带来的开销

### 什么是Reactor 模式

关键词: ***I/O多路复用***   ***非阻塞 I / O*** ***event-loop*** 

Reactor 模式本质上指的是使用 `I/O 多路复用(I/O multiplexing) + 非阻塞 I/O(non-blocking I/O)` 的模式。

通常设置一个主线程负责做 event-loop 事件循环和 I/O 读写，通过 select/poll/epoll_wait 等系统调用监听 I/O 事件，业务逻辑提交给其他工作线程去做。

### Redis 多线程是怎么工作的？ 有什么缺陷？

工作原理:

分为主线程和IO线程，IO负责网络 I/O 和命令解析部分，主线程负责分发请求和执行命令。

执行步骤：

1. 多线程初始化

2. 读取请求

   - 遍历待读取的 `client` 队列 `clients_pending_read`，通过 RR 策略把所有任务分配给 I/O 线程和主线程去读取和解析客户端命令。

   - 忙轮询等待所有 I/O 线程完成任务。
   - 最后再遍历 `clients_pending_read`，执行所有 `client` 的命令。

3. 写回响应

   - 唤醒正在休眠的 I/O 线程（如果有的话）。
   - 遍历待写出的 `client` 队列 `clients_pending_write`，通过 RR 策略把所有任务分配给 I/O 线程和主线程去将响应数据写回到客户端。
   - 忙轮询等待所有 I/O 线程完成任务


缺陷：

I/O 线程任务仅仅是通过 socket 读取客户端请求命令并解析，却没有真正去执行命令，所有客户端命令最后还需要回到主线程去执行，因此对多核的利用率并不算高，而且每次主线程都必须在分配完任务之后忙轮询等待所有 I/O 线程完成任务之后才能继续执行其他逻辑。

Redis 之所以如此设计它的多线程网络模型，主要的原因是为了保持兼容性，因为以前 Redis 是单线程的，所有的客户端命令都是在单线程的事件循环里执行的，也因此 Redis 里所有的数据结构都是非线程安全的.

### 其他主流的开源网络服务器的模型是什么样子呢？

关键词：***Multi-Reactors/Master-Workers*** 模式

回答:

在标准的 Multi-Reactors/Master-Workers 模式下，Sub Reactors/Workers 会完成 `网络读 -> 数据解析 -> 命令执行 -> 网络写` 整套流程，Main Reactor/Master 只负责分派任务.。

比如 Nginx 和 Memcached 就用到了这种模式。

参考资料：

[Redis 多线程网络模型全面揭秘](https://strikefreedom.top/multiple-threaded-network-model-in-redis)