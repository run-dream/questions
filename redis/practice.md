### 如何利用ziplist来节省内存？

关键词： ***二级编码***

适用场景:额外元数据开销大于实际存储的数据，比如用String类型来存储大量的非整数短字符串时

回答：

1. 设置hash-max-ziplist-entries和hash-max-ziplist-value
2. 将key拆分成 key1 和 key2， 确保 key2的值小于hash-max-ziplist-entries，从而redis采用ziplist来保存数据

缺点是：

1. 无法单独设置过期时间
2. 修改可能出现性能问题



### 怎么利用Redis来进行统计

注意：

集群情况下用不了。

场景：

1. 聚合统计

   就是指统计多个集合元素的聚合结果

   利用SET类型来处理

2. 排序统计

   考虑到数据更新的问题使用Sorted Set 的 ZRANGEBYSCORE

3. 二值状态统计

   集合元素的取值就只有 0 和 1 两中

   Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。

   BITGET/BITSET/ BITOP/BITCOUNT

4. 基数统计

   指统计一个集合中不重复的元素个数

   - SET/ HASH 会消耗大量内存
   - HyperLogLog 集合元素量达到亿级别而且不需要精确统计时



### Redis 如何处理地理信息（LBS）？

关键词: ***GEO***

回答：

Redis提供了GEO类型来存储和处理LBS信息。

1. GEO 类型的底层数据结构就是用 Sorted Set 来实现的

2. GeoHash 编码

   二分区间，区间编码。

   1. 对经度[-180,180]进行N次二分区处理，跟进落在左右分区进行0，1划分，N次以后获取到一个Nbit的数
   2. 对维度[-90,90]进行同样的处理
   3. 按照偶数位是经度，奇数位是纬度将各自编码值组合在一起

   查找的时候

   将编码按照从下向上，z字形编码映射到一维空间，查找时，查询其相邻的四个或8个空间。



### Redis 如何保证操作原子性？

关键词: ***MULTI EXEC*** ***PIPELINE***





### Redis 如何做消息队列?

消息队列的核心需求：

1. 消息保序
2. 重复消息处理
3. 消息可靠性保证

Redis怎么解决这三个需求:

1. 基于 List 的消息队列解决方案

   方案:

   生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使用 RPOP/BRPOP/BRPOPLPUSH 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理

   - rpop
   - brpop 增加阻塞 避免客户端盲等
   - brpoplpush 增加备份到某个队列 

   缺陷:

   1. 只支持一个生产者，一个消费者
   2. 需要用户自己管理唯一Id，实现幂等

2. 基于pub/sub的消息广播

   方案:

   生产者发送消息，订阅者接收消息

   - PUBLISH 
   - SUBSCRIBE

   缺陷:

   1. 如果任意一个消费者挂了，等恢复过来后，在这期间的生产者的数据就丢失了
   2. PubSub中的数据不支持数据持久化，当Redis宕机恢复后，其他类型的数据都可以从RDB和AOF中恢复回来，但PubSub不行，它就是简单的基于内存的多播机制

3. 基于 Streams 的消息队列解决方案（Redis 5.0）

   方案：

   - XADD：插入消息，保证有序，可以自动生成全局唯一 ID
   - XREAD：用于读取消息，可以按 ID 读取数据
   - XGROUP: 创建消费组
   - XREADGROUP：按消费组形式读取消息，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。
   - XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。



###  如何避免主线程的阻塞？

关键词: ***关键路径***

可能导致阻塞的因素：

1. 网络IO
2. 分配/回收内存
3. 读写磁盘
4. CPU密集的计算

可能导致阻塞的操作和解决方案

1. 集合全量查询和聚合操作

   在关键路径上，无法通过异步来解决，只能减少此类操作或者限制集合大小

2. bigkey 删除操作

   惰性删除。用UNLINK替代DEL，将key标记删除后，用异步线程来回收内存

3. 清空数据库

   以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库

4. AOF 日志同步写

    AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志

5. 从库加载 RDB 文件

   在关键路径上，无法通过异步来解决，只能把主库的数据量大小控制在 2~4GB 左右，保证较快的速度加载

基于异步的思路来避免主线程阻塞



### 为什么CPU结构也会影响Redis的性能？

关键词: ***N******UMA***

回答：

- 一个 CPU 处理器中一般有多个运行核心，称为一个物理核，每个物理核都可以运行应用程序
- 每个物理核都拥有私有的 L1 cache，包括一级指令缓存和一级数据缓存，以及L2 cache，速度非常快
- 不同的物理核还会共享一个共同的 L3 cache，访问其他CPU的L3 cache 会比访问自己CPU的L3 cache慢
- 不同处理器间通过总线连接
- 在多 CPU 架构上，应用程序可以在不同的处理器上运行
- 在 CPU 多核的环境中，一个线程先在一个 CPU 核上运行，之后又切换到另一个 CPU 核上运行，这时就会发生 context switch。

方案：

在 CPU 多核的环境下，通过绑定 Redis 实例和 CPU 核，可以有效降低 Redis 的尾延迟。

缺陷：

1. 如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存，这个过程会花费较多时间。
2. 当我们把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加。

优化：

1. 一个 Redis 实例对应绑一个物理核
2. 修改 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上



### Redis变慢了怎么办？

- 怎么判断Redis是不是变慢了？

  - 查看 Redis 的响应延迟

    可以通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求

  - 对比当前环境下的 Redis 基线性能

    ```bash
    redis-cli --intrinsic-latency 120
    ```

- 怎么分析Redis是因为什么原因变慢的？怎么解决？

  - 从慢查询命令开始排查，并且根据业务需求替换慢查询命令

    - 不要使用 SMEMBERS 命令，而是要使用 SSCAN 多次迭代返回
    - 当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例
    - 禁用KEYS

  - 排查过期 key 的时间设置

    根据实际使用需求，设置不同的过期时间

  - 排查是否存在 bigkey 

    ```bash
    ./redis-cli --bigkeys
    ```

    或者用rdb-tools 

     对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。

  - 查看Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？

    如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。

  - Redis 实例的内存使用是否过大？发生 swap 了吗？

    如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。

  - 在 Redis 实例的运行环境中，是否启用了透明大页机制？

    如果是的话，直接关闭内存大页机制就行了

  - 是否运行了 Redis 主从集群？

    如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。

  - 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？

    使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。



### 删除数据后，为什么内存占用率还是很高？

原因：

1. 当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统

2. 内存碎片

   形成原因：

   内因是操作系统的内存分配机制  libc、jemalloc、tcmalloc  

   外因是 Redis 的负载特征 键值对大小不一样和删改操作

如何排查：

INFO 命令   mem_fragmentation_ratio = used_memory_rss/ used_memory

如何处理

1. 重启 Redis 实例 

   缺点是：没有持久化，那么，数据就会丢失，持久化了恢复阶段无法提供服务

2. 启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes



### 缓冲区

Redis缓冲区分类:

- 客户端的输入输出缓冲区
- 主从集群中主节点上的复制缓冲区和复制积压缓冲区

Redis缓冲区错误分类：

- 缓冲区溢出导致网络连接关闭

  客户端的输入输出缓冲区

- 缓冲区溢出导致命令数据丢失

  主从集群中主节点上的复制缓冲区和复制积压缓冲区

应对策略：

- 针对命令数据发送过快过大的问题，对于普通客户端来说可以避免 bigkey，而对于复制缓冲区来说，就是避免过大的 RDB 文件
- 针对命令数据处理较慢的问题，解决方案就是减少 Redis 主线程上的阻塞操作，例如使用异步的删除操作
- 针对缓冲区空间过小的问题，解决方案就是使用 client-output-buffer-limit 配置项设置合理的输出缓冲区、复制缓冲区和复制积压缓冲区大小



### [Redis 缓存模式有哪些？适合于什么场景？ 有什么缺陷?](https://coolshell.cn/articles/17416.html)

- cache-aside

  逻辑：

  - 查询：程序先从cache中获取数据，有数据直接返回，没有得到，则去数据库中取数据，成功后更新到缓存中。
  - 更新：先把数据存到数据库中，成功后，再让缓存失效。

  优点: 数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。

  缺点: 每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大

- read/write through

  将 缓存服务 作为主要的存储，应用的所有读写请求都是直接与缓存服务打交道，而不管最后端的数据库了，数据库的数据由缓存服务来维护和更新。不过缓存中数据变更的时候是同步去更新数据库的

  优点:被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存，不用再从后端数据库中查询，这个过程拥有比较好的性能，比较适合先修改又立即访问的业务场景。

  缺点:在高并发场景下，如果存在多个操作同时修改同一个值的情况，可能会导致缓存和数据库的不一致。

  - read through

    Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。

  - write through

    在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库

  - write behind (write back)

    在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。
