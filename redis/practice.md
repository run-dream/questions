### 如何利用ziplist来节省内存？

关键词： ***二级编码***

适用场景:额外元数据开销大于实际存储的数据，比如用String类型来存储大量的非整数短字符串时

回答：

1. 设置hash-max-ziplist-entries和hash-max-ziplist-value
2. 将key拆分成 key1 和 key2， 确保 key2的值小于hash-max-ziplist-entries，从而redis采用ziplist来保存数据

缺点是：

1. 无法单独设置过期时间
2. 修改可能出现性能问题



### 怎么利用Redis来进行统计

注意：

集群情况下用不了。

场景：

1. 聚合统计

   就是指统计多个集合元素的聚合结果

   利用SET类型来处理

2. 排序统计

   考虑到数据更新的问题使用Sorted Set 的 ZRANGEBYSCORE

3. 二值状态统计

   集合元素的取值就只有 0 和 1 两中

   Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。

   BITGET/BITSET/ BITOP/BITCOUNT

4. 基数统计

   指统计一个集合中不重复的元素个数

   - SET/ HASH 会消耗大量内存
   - HyperLogLog 集合元素量达到亿级别而且不需要精确统计时



### Redis 如何处理地理信息（LBS）？

关键词: ***GEO***

回答：

Redis提供了GEO类型来存储和处理LBS信息。

1. GEO 类型的底层数据结构就是用 Sorted Set 来实现的

2. GeoHash 编码

   二分区间，区间编码。

   1. 对经度[-180,180]进行N次二分区处理，跟进落在左右分区进行0，1划分，N次以后获取到一个Nbit的数
   2. 对维度[-90,90]进行同样的处理
   3. 按照偶数位是经度，奇数位是纬度将各自编码值组合在一起

   查找的时候

   将编码按照从下向上，z字形编码映射到一维空间，查找时，查询其相邻的四个或8个空间。



### Redis 如何保证操作原子性？

关键词: ***MULTI EXEC*** ***PIPELINE***





### Redis 如何做消息队列?

消息队列的核心需求：

1. 消息保序
2. 重复消息处理
3. 消息可靠性保证

Redis怎么解决这三个需求:

1. 基于 List 的消息队列解决方案

   方案:

   生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使用 RPOP/BRPOP/BRPOPLPUSH 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理

   - rpop
   - brpop 增加阻塞 避免客户端盲等
   - brpoplpush 增加备份到某个队列 

   缺陷:

   1. 只支持一个生产者，一个消费者
   2. 需要用户自己管理唯一Id，实现幂等

2. 基于pub/sub的消息广播

   方案:

   生产者发送消息，订阅者接收消息

   - PUBLISH 
   - SUBSCRIBE

   缺陷:

   1. 如果任意一个消费者挂了，等恢复过来后，在这期间的生产者的数据就丢失了
   2. PubSub中的数据不支持数据持久化，当Redis宕机恢复后，其他类型的数据都可以从RDB和AOF中恢复回来，但PubSub不行，它就是简单的基于内存的多播机制

3. 基于 Streams 的消息队列解决方案（Redis 5.0）

   方案：

   - XADD：插入消息，保证有序，可以自动生成全局唯一 ID
   - XREAD：用于读取消息，可以按 ID 读取数据
   - XGROUP: 创建消费组
   - XREADGROUP：按消费组形式读取消息，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。
   - XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。

