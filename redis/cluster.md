### 为什么要用集群？

1. 单机存不下那么多数据
2. 即使单机能存下那么多数据，但是在启用了RDB日志的情况下，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。

### 集群要解决哪些问题？

1. 数据切片后，在多个实例之间如何分布？

   关键词：***哈希槽***

   回答：

   在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。

   **首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。再通过槽与节点的对应关系找到节点。**

   redis支持平均分配或者手动分配：

   - cluster create 
   - cluster meet cluster addslots，需要把 16384 个槽都分配完

   相比一致性哈希，缺点是**所有节点都需要知道槽与节点对应关系，如果client端不保存槽与节点的对应关系的话，它需要实现重定向的逻辑**。

2. 客户端怎么确定想要访问的数据在哪个实例上？

   客户端可以在访问任何一个实例时，都能获得所有的哈希槽信息。是通过：

   - Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成**哈希槽分配信息的扩散**。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。

   - Redis Cluster 方案提供了一种**重定向**机制，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。

     - MOVED 迁移完了 返回新实例地址
     - ASK 表明 Slot 数据还在迁移中 客户端需要向新的服务器发送ASKING 再重新GET

     ASK 命令并不会更新客户端缓存的哈希槽分配信息

### 除了Redis Cluster 还有哪些集群方案？

基于主从的

- Codis
- Twemproxy 

### [一致性哈希是什么？](https://segmentfault.com/a/1190000021199728)

关键词: ***一致性哈希环*** ***虚拟节点***

解决的问题:  

传统哈希面对

- 节点减少 
- 节点增加

的情况时，需要**重新分配所有现有键的方案**

一致性hash的核心思想为**将key作hash运算**, 并按一定规律取整得出0-2^32-1之间的值, 环的大小为2^32，key计算出来的整数值则为key在hash环上的位置，如何将一个key，映射到一个节点， 这里分为两步. 

- 第一步, 将服务的key按该hash算法计算,得到在**服务**在一致性hash环上的位置.
- 第二步, 将缓存的key，用同样的方法计算出**key**在hash环上的位置，按顺时针方向，找到第一个大于等于该hash环位置的服务key，从而得到该key需要分配的服务器。

简单实现：https://github.com/run-dream/hash-ring

### 为什么是2^14次方个slot?

1. `CRC16`算法产生的hash值有16bit，该算法可以产生2^16-=65536个值
2.   redis 采用bitmap来保存哈希槽
3.  如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大，浪费带宽
4.  redis的集群主节点数量基本不可能超过1000个。集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵
5.  槽位越小，节点少的情况下，压缩比高

### 参考文档

[【原创】那些年用过的Redis集群架构（含面试解析）](https://www.cnblogs.com/rjzheng/p/10360619.html)

[为什么Redis集群有16384个槽](https://zhuanlan.zhihu.com/p/80335611)



