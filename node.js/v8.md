### 知识框架

- 基础环境
  - 堆空间
    - 树状存储结构
    - 存储对象
    - 存储闭包函数引用的原生类型
  - 栈空间
    - FIFO
    - 存储原生类型
  - 全局执行上下文
    - 初始化的this
    - 全局作用域
    - 全局对象
  - 宿主环境
    - 宿主类型
      - 浏览器
      - Node.js
      - 其他宿主
    - 内置
      - 内置函数
      - 内置对象
        - Chrome.window
        - Node.global
  - ***事件循环系统***
    - 消息队列
    - 任务调度系统

- V8执行流程

  - 词法分析

  - 语法分析
    - AST
    - 作用域
    - 惰性编译
    - 预编译器
    - 预解析器
  - 字节码
  - 解释执行字节码
    - 基于寄存器的虚拟机
  - 即时编译 JIT
    - 监控器
    - 编译器
    - 隐藏类
    - 反优化

- 事件循环系统

  - 什么是事件循环系统

    - JavaScript 是单线程模式
    - 单线程同时只能执行一个任务
    - 有新的任务就需要排队执行 
    - 引入消息队列
    - 消息队列的任务是宏任务
    - 任务调度器
      - 循环读取消息队列中的任务
      - 分派给指定的任务处理器

  - 异步编程

    - 回调函数

      缺点

      - 可读性差
      - 代码维护难
      - 回调地狱

    - Promise模式 （本质是状态机）

      - 半同步的方式编写异步代码
      - 使用了微任务
      - 改造了回调函数
      - 可读性提升

    - async/await方式 （本质是对 Generator 和 Promise 组合)

      - 以同步的方式来写异步代码
      - 使用了微任务
      - 使用了协程
      - 可读性大幅提升
      - 背后原理

- JavaScript 设计思想

  - 函数是一等公民
  - 类型系统和垃圾回收
  - 作用域
  - 原型链继承

- 垃圾回收系统

  - 活动对象和非活动对象的区分方案
    - 自动引用计数  Objective-C 缺点不好解决循环引用的问题
    - 可访问性（reachability）算法 go,nodejs,java 
      - 三色抽象算法

  - 自动垃圾回收
  - 回收方式
    - 手动
    - 智能指针
      - 引用计数
    - 自动内存管理
      - 根元素遍历
  - 代记假说
    - 大多数对象都是短命的
    - 不短命的会活很久
  - 分代收集
    - 新生代 垃圾回收 区域互换
      - 对象区域
      - 空闲区域
    - 老生代 标记、清除和整理
  - 垃圾回收器
    - 主垃圾回收器 老生代
    - 副垃圾回收器 新生代
  - 垃圾回收流程
    - stop the world

      - 增量回收 三色标记法
        - 黑白灰三色
        - 写屏障 (Write-barrier) 机制
        - 约束：不能让黑色节点指向白色节点
      - 并行回收 
        - 主线程在执行垃圾回收的任务时，引入多个辅助线程来并行处理

      - 并发 (concurrent) 回收


### 为什么V8比较快

关键词: ***隐藏类型***  ***JIT***

回答:

我们从V8的执行过程来分析，基本分为下面几个流程

编译 -> AST + 作用域 -> 字节码 -> 解释执行 -> 优化 -> 反优化

我们都知道编译执行比解释执行要快， V8采用了混合使用编译器和解释器的JIT（Just In Time）技术。

具体来说，是先生成字节码，然后解释执行，并统计热点代码，将热点代码优化为机器代码并缓存，同时热点代码失效以后，编译器还能执行反优化操作。

此外在运行过程中，V8为了在内存中快速查找对象属性，会假设 JavaScript 中的对象是静态的，为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息。



### V8的事件循环是怎么实现

关键词: ***消息队列*** ***任务管理系统***

回答：

首先我们需要了解JavaScript的线程模型：

1. 一个主线程来处理主要的任务
2. 多个IO线程处理IO，网络相关的异步任务

主线程在执行过程中，如果遇到了事件，不能停下当前的工作去执行，而是将其放到消息队列里。

我们把 UI 线程每次从消息队列中取出事件，执行事件的过程称为一个任务。

- 宏任务 消息队列中的等待被主线程执行的事件 setTimeout 回调
- 微任务 微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

微任务是用来解决宏任务执行时机不可控的问题

### V8的垃圾回收是怎么工作的

关键词： ***分代*** ***主副垃圾回收器***

回答：

分代假说。将堆分为

1. 老生带 生存时间久的对象 使用主垃圾回收器
2. 新生代 是生存时间短的对象 使用附垃圾回收器

新生代中的垃圾数据划分为两个区域，一半是对象区域 (from-space)，一半是空闲区域 (to-space)。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。主垃圾回收器回收器主要负责老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程。

V8采用可访问性（reachability）算法来判断对象是否有引用。采用了三色标记法来标记。

如何防止全停顿

- 增量回收 三色标记法
  - 黑白灰三色
  - 写屏障 (Write-barrier) 机制
  - 约束：不能让黑色节点指向白色节点
- 并行回收 
  - 主线程在执行垃圾回收的任务时，引入多个辅助线程来并行处理

- 并发 (concurrent) 回收

  主线程执行的时候，辅助线程可以进行垃圾回收



